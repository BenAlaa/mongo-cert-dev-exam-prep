- from 3.4
- filter the information
1- single facet: > sortByCount in utility
2- bucketing: 
    - divide information into buckets based on boundaries
    - $bucket: {
        groupBy: <expression>,
        boundaries: [0, 20, 50, 100, 500, ...], lower > inclusive | upper > exclusive
        default: "", > optional > for values that doesn't fall in boundary
        output: { > optional
            total: <accummulator_expression>,
            average: <accummulator_expression>,
            categories: <accummulator_expression>,
        }
    }   
    - count is removed when output is specified ***********
    - boundary must be of the same type as expression and each expression must fall within a boundary or specify default
    - returns: { _Id: <boundary>, count: <int> }
3- Automatic buckets:
    - $bucketAuto: {
        groupBy: <expression>,
        buckets: <int_num_of_buckets>,
        granularity: <optional_see_documentation>,  // it uses pre-defined series to use when bucketing
        ... same as bucket
    }
    - result: { _id: { min: <inclusive>, max: <exclusive> }, count: <int> }
4- $facet:
    - { 
        $facet:
          {
              <outputField1>: [ <stage1>, <stage2>, ... ],
              <outputField2>: [ <stage1>, <stage2>, ... ],
              ...
          }
      }
    - combines multiple facets in a single stage
    - each sub-stage gets the same input documents to the $facet stage
    - can't be nested inside another facet